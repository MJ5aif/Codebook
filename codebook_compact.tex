\documentclass[10pt,twocolumn]{article}

\usepackage[margin=1.0cm,includehead]{geometry}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{multicol}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc} % Ensures proper character encoding
\usepackage{textcomp} % For text symbols
\usepackage[space=true]{accsupp} % For copyable spaces

% Header: page number (right) and team name (left) on every page
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}
\fancyhead[L]{\textbf{Names Are Irrelevant}}
\fancyfoot{}
\renewcommand{\headrulewidth}{0pt}
\fancypagestyle{plain}{%
  \fancyhf{}
  \fancyhead[R]{\thepage}
  \fancyhead[L]{\textbf{Names Are Irrelevant}}
  \renewcommand{\headrulewidth}{0pt}
}

% Command for copyable space
\newcommand{\copyablespace}{\BeginAccSupp{method=hex,unicode,ActualText=00A0}\hphantom{x}\EndAccSupp{}}

\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{keyword}{rgb}{0.0,0.0,1.0}    % blue
\definecolor{type}{rgb}{0.0,0.5,0.0}       % green
\definecolor{stl}{rgb}{0.58,0.0,0.82}      % purple
\definecolor{comment}{rgb}{0.0,0.5,0.0}    % green
\definecolor{string}{rgb}{0.8,0.42,0.24}   % orange
\definecolor{number}{rgb}{0.63,0.13,0.94}  % purple
\definecolor{function}{rgb}{0.0,0.5,1.0}   % cyan for functions
\definecolor{operator}{rgb}{1.0,0.0,1.0}   % magenta for operators

\lstdefinelanguage{cpp}{
  morekeywords=[1]{cin,cout,ios,alignas,std,alignof,asm,auto,break,case,catch,class,const,constexpr,define,memset,
  continue,decltype,default,delete,do,else,enum,explicit,export,extern,false,for,
  friend,if,inline,mutable,namespace,new,noexcept,nullptr,operator,private,
  protected,public,register,return,static,struct,switch,template,this,throw,true,
  try,typedef,typeid,typename,using,virtual,void,volatile,while},
  morekeywords=[2]{stdin,stdout,bool,char,double,float,int,int32_t, int64_t,long,short,signed,unsigned,void,uint64_t},
  morekeywords=[3]{array,ordered_set,vector,map,set,unordered_map,unordered_set,string,pair,tuple},
  morekeywords=[4]{foo,cross,freopen,dot,dist,add,maxxor,insert,bxor,update,query,combine,init,find,merge,NULL,custom_hash,rng,z_func,manacher_odd,suffix_array,BitTrie,Hash,Hashing,BIT,BIT2D,RangeBIT,upd,sum},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  numbers=left,
  numberstyle=\tiny\color{number},
}

\lstset{
  language=cpp,
  basicstyle=\ttfamily\footnotesize\color{black},
  keywordstyle=[1]\color{keyword}\bfseries,
  keywordstyle=[2]\color{type}\bfseries,
  keywordstyle=[3]\color{stl}\bfseries,
  keywordstyle=[4]\color{function}\bfseries,
  commentstyle=\color{comment}\itshape,
  stringstyle=\color{string},
  backgroundcolor=\color{codebg},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=8pt,
  xleftmargin=2.2em,
  framexleftmargin=2.2em,
  framesep=2pt,
  frame=single,
  rulecolor=\color{gray},
  keepspaces=true,
  columns=fullflexible,
  breaklines=true,
  aboveskip=2pt,
  belowskip=2pt,
  showstringspaces=false,
  commentstyle=\color{comment}\itshape, % Green, italic comments
  literate={*}{{\color{operator}\char42}}1
           {-}{{\color{operator}\char45}}1
           {+}{{\color{operator}+}}1
           {=}{{\color{operator} = }}1
           {==}{{\color{operator}== }}1
           {!}{{\color{operator}!}}1
           {.}{{\color{operator}.}}1
           % \literate={^}{{\color{operator}\^{}}}1
           {<}{{\color{operator}<}}1
           {:}{{\color{operator}:}}1
           {>}{{\color{operator}>}}1
           {&}{{\color{operator}\&}}1
           {|}{{\color{operator}|}}1
           {\ }{{\copyablespace}}1
}

\titlespacing*{\section}{0pt}{1pt}{1pt}
\titlespacing*{\subsection}{0pt}{1pt}{1pt}

\title{TEAM NOTEBOOK --- Names Are Irrelevant (SUST)}
\author{MJ5aif}
\date{\today}

\makeatletter
\renewcommand{\@maketitle}{%
  \newpage
  \null
  \vskip -10pt % Adjust this value to reduce space (negative to decrease)
  \begin{center}
    \let \footnote \thanks
    {\LARGE \@title \par}
    \vskip 1.5em % Space between title and author
    {\large
      \lineskip .5em%
      \begin{tabular}[t]{c}
        \@author
      \end{tabular}\par}
    \vskip 1em % Space between author and date
    {\large \@date}
  \end{center}
  \par
  \vskip 1em % Space after date
}
\makeatother

\begin{document}
% Title + 3-column ToC on the FIRST page (no blank first page)
\begingroup
\onecolumn

\makeatletter
% Temporarily disable the forced page break inside your \@maketitle
\let\saved@newpage\newpage
\let\newpage\relax
\makeatother

% Optional tightening (leave commented if you don't need it)
\vspace*{-0.5em}
\maketitle
\vspace*{-0.75em}

\makeatletter
% Restore normal behavior
\let\newpage\saved@newpage
\makeatother

% Three-column ToC
\setlength{\columnsep}{10pt}
\setlength{\columnseprule}{0pt}
\begin{multicols}{3}
\footnotesize
\tableofcontents
\end{multicols}

\endgroup
\twocolumn
\bigskip

\section{Templates}
\subsection{BUILD}
\begin{lstlisting}
{
"cmd" : ["g++ -std=c++20 $file_name -o $file_base_name && timeout 5s ./$file_base_name<input.txt>output.txt"],
"selector" : "source.cpp",
"shell": true,
}
\end{lstlisting}

\subsection{STD and Fast IO}
\begin{lstlisting}
freopen("mj5.in", "r", stdin);  freopen("mj5.out", "w", stdout);
ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
\end{lstlisting}

\subsection{VS Code Snippet}
\begin{lstlisting}
{
  "snippetName": {
    "scope": "",
    "prefix": "TabTrigger", // replace it 
    "body": [
      "", // every lines must inside->  "",
    ],
    "description": ""
  }
}
// to genrate lines with "", bash command:
cat mj5.cpp | sed 's/\\/\\\\/g; s/"/\\"/g; s/^/"/; s/$/",/'      
\end{lstlisting}

\subsection{Formulas}
\begin{lstlisting}
* (a | b) =(a^b)|(a&b)       * a^(a&b) =(a|b)^b
* b^(a&b) =(a|b)^a           * (a&b)^(a|b) =(a^b)
* (a+b) =(a^b) + 2*(a&b)     * (a+b) =(a|b) + (a&b) //plus
* (a-b) =(a^(a&b))-((a|b)^a) * (a-b) =(a^(a&b))-(b^(a&b)) 
* (a-b) =((a|b)^b)-(b^(a&b)) * (a-b) =((a|b)^b)-((a|b)^a)
\end{lstlisting}

\subsection{Ordered Set}
\begin{lstlisting}
// find_by_order() -> iterator // order_of_key() -> int
// inside main function Just declare ordered_set
// change Type by replacing int
#include <ext/pb_ds/assoc_container.hpp> 
#include <ext/pb_ds/tree_policy.hpp> 
using namespace __gnu_pbds;   
#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>
\end{lstlisting}

\subsection{Num}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{Custom Hash}
\begin{lstlisting}
struct custom_hash{
static uint64_t sm64(uint64_t x){x+=0x9e3779b97f4a7c15; x=(x^(x>>30))*0xbf58476d1ce4e5b9; x=(x^(x>>27))*0x94d049bb133111eb; return x^(x>>31);} // must
size_t operator()(uint64_t x) const{static const uint64_t R=chrono::steady_clock::now().time_since_epoch().count(); return sm64(x+R);} // int
template<class T1,class T2> size_t operator()(const pair<T1,T2>&p) const{size_t h1=(*this)((uint64_t)p.first),h2=(*this)((uint64_t)p.second); return h1^(h2+0x9e3779b9+(h1<<6)+(h1>>2));} // pair<int,int>
template<class...Ts> size_t operator()(const tuple<Ts...>&t) const{size_t s=0; apply([&](const auto&...e){((s^=(*this)((uint64_t)e)+0x9e3779b9+(s<<6)+(s>>2)),...);},t); return s;} // tuple<int>
template<class T> size_t operator()(const vector<T>&v) const{size_t s=v.size(); for(auto&x:v) s^=(*this)((uint64_t)x)+0x9e3779b9+(s<<6)+(s>>2); return s;}
}; // vector<int> 
\end{lstlisting}

\subsection{Random Number Genrator}
\begin{lstlisting}
int64_t rng(){
   static std::mt19937 gen(std::chrono::steady_clock::now().time_since_epoch().count());
   return std::uniform_int_distribution<int>(1, INT64_MAX)(gen);
}
\end{lstlisting}

\section{Strings}
\subsection{Z-Algo}
\begin{lstlisting}
vector<int> z_func(string &s){
   int n=s.size(),l=0,r=0;    vector<int> z(n);
   for(int i=1;i<n;i++){
      if(i<r)     z[i]=min(r-i,z[i-l]);
      while(i+z[i]<n && s[z[i]]==s[i+z[i]])   z[i]++;
      if(i+z[i]>r){  l=i;     r=i+z[i];   }
   }
   return z;
}
\end{lstlisting}

\subsection{Manacher's Algo}
\begin{lstlisting}
vector<int> manacher_odd(string s) {
    int n = s.size();
    s = "$" + s + "^";
    vector<int> p(n + 2);
    int l = 0, r = 1;
    for(int i = 1; i <= n; i++) {
        p[i] = min(r - i, p[l + (r - i)]);
        while(s[i - p[i]] == s[i + p[i]]) {
            p[i]++;
        }
        if(i + p[i] > r) {
            l = i - p[i], r = i + p[i];
        }
    }
    return vector<int>(begin(p) + 1, end(p) - 1);
}    
\end{lstlisting}

\subsection{Basic Suffix Array}
\begin{lstlisting}
void suffix_array(string s){
   s+="$";  int32_t n=s.size(),N=max(n,int32_t(260));
   vector<int32_t> sa(n),R(n);
   for(int32_t i=0;i<n;i++)  sa[i]=i,  R[i]=s[i];
   for(int32_t k=0;k<n;k?(k<<=1):k++){
      vector<int32_t> nR(n),cnt(N);    auto nsa=sa;
      for(int32_t i=0;i<n;i++) nsa[i]=(nsa[i]-k+n)%n,  cnt[R[i]]++;
      for(int32_t i=1;i<N;i++) cnt[i]+=cnt[i-1];
      for(int32_t i=n-1;i>=0;i--) sa[--cnt[R[nsa[i]]]]=nsa[i];
      for(int32_t i=1,r=0;i<n;i++){
         r+=(R[sa[i]]!=R[sa[i-1]] || R[(sa[i]+k)%n]!=R[(sa[i-1]+k)%n]);
         nR[sa[i]]=r;
      }  
      swap(R,nR);
   }
   vector<int32_t> lcp(n-1);
   for(int32_t i=0,k=0;i<n-1;i++){
      int32_t pi=R[i];
      int32_t j=sa[pi-1];
      while(i+k<n && j+k<n && s[i+k]==s[j+k])   k++;
      lcp[pi-1]=k;
      if(k) k--;
   }
}
\end{lstlisting}

\subsection{Trie}
\begin{lstlisting}

\end{lstlisting}

\subsection{BitTrie}
\begin{lstlisting}
const int Log = 31; 
struct BitTrie{
   int cur;     vector<array<int,2>> nxt;
   BitTrie(int n){
      cur=1;
      nxt=vector<array<int,2>>((n+5)*Log,{-1,-1});
   }
   void insert(int x){
      int node=0;
      for(int i=Log-1;i>=0;i--){
         int bt=((x>>i)&1);
         if(nxt[node][bt]==-1) nxt[node][bt]=cur++;
         node=nxt[node][bt];
      }
   }
   int bxor(int x){
      int node=0,res=0;
      for(int i=Log-1;i>=0;i--){
         int bt=(((x>>i)&1)^1);
         if(nxt[node][bt]!=-1){
            res|=(1LL<<i);
            node=nxt[node][bt];
         }else if(nxt[node][bt^1]!=-1){
            node=nxt[node][bt^1];
         }else break;
      }
      return res;
   }
};
\end{lstlisting}

\subsection{String Hashing}
\begin{lstlisting}
#define int int64_t
const int SZ=int(1e6)+9;
const int B1=151,B2=239;
const int mod1=127657753,mod2=987654319;
vector<int> P1(SZ,1),P2(SZ,1);
void pow_cal(){ // call pow_cal() inside main function once
   for(int i=1;i<SZ;i++){
      P1[i]=(P1[i-1]*B1)%mod1;
      P2[i]=(P2[i-1]*B2)%mod2;
   }
}
class Hash{
public:
   int n;   vector<int> H1,H2;
   Hash(const string& s){
      n=s.size();
      H1.assign(n+1,0); H2.assign(n+1,0);
      for(int i=1;i<=n;i++){
         H1[i]=(H1[i-1]+((s[i-1]-'a'+1)*P1[i])%mod1)%mod1;
         H2[i]=(H2[i-1]+((s[i-1]-'a'+1)*P2[i])%mod2)%mod2;
      }
   }
   pair<int,int> geth(int l, int r){
      int h1=(((H1[r]-H1[l-1]+mod1)%mod1)*P1[SZ-l])%mod1;
      int h2=(((H2[r]-H2[l-1]+mod2)%mod2)*P2[SZ-l])%mod2;
      return make_pair(h1,h2);
   }
   pair<int,int> geth()    return geth(1,n);
};
\end{lstlisting}

\subsection{2D Hashing}
\begin{lstlisting}
struct Hashing {
   int n,m;     static const int PX=3731,PY=2999,mod=998244353;
   vector<int> PWX,PWY;   vector<vector<int>> hs;
   Hashing(){}  
   Hashing(vector<string>& s){
      n=(int)s.size(), m=(int)s[0].size();
      hs.assign(n+1,vector<int>(m+1,0));
      PWX.assign(n+1,1);     PWY.assign(m+1,1);
      for(int i=0;i<n;i++) PWX[i+1]=1LL*PWX[i]*PX%mod;
      for(int i=0;i<m;i++) PWY[i+1]=1LL*PWY[i]*PY%mod;
      for(int i=0;i<n;i++){
         for(int j=0;j<m;j++){
            hs[i+1][j+1]=s[i][j]-'a'+1;
         }
      }
      for(int i=0;i<=n;i++){
         for(int j=0;j<m;j++){
         hs[i][j+1]=(hs[i][j+1]+1LL*hs[i][j]*PY%mod)%mod;
         }
      }
      for(int i=0;i<n;i++){
         for(int j=0;j<=m;j++){
         hs[i+1][j]=(hs[i+1][j]+1LL*hs[i][j]*PX%mod)%mod;
         }
      }
  }
  int get_hash(int x1,int y1,int x2,int y2) { // 1-indexed
    assert(1<=x1 && x1<=x2 && x2<=n);
    assert(1<=y1 && y1<=y2 && y2<=m);
    x1--;   y1--;
    int dx =x2-x1, dy =y2-y1;
    return (1LL * (hs[x2][y2] - 1LL * hs[x2][y1] * PWY[dy] % mod + mod) % mod - 1LL * (hs[x1][y2] - 1LL * hs[x1][y1] * PWY[dy] % mod + mod) % mod * PWX[dx] % mod + mod) % mod;
  }
  int get_hash()     return get_hash(1, 1, n, m);
};
\end{lstlisting}

\subsection{Longest Palindrome from any Index}
\begin{lstlisting}
// needs Hashing 
void lp(string& s){
   int n=s.size();      string t=s;
   reverse(t.begin(),t.end());
   Hash sh(s),th(t);
   auto f=[&](int L, int R){
      auto ss=sh.geth(L,R);
      auto tt=th.geth(n-R+1,n-L+1);
      return (ss==tt);
   };
   vector<int> R(n,1),L(n,1); 
   for(int i=n-1,r=n-1;i>=0;i--){
      if(r<n-1 && s[i]==s[r+1]){
         r++;
      }else{
         while(!f(i+1,r+1))      r--;
      }
      R[i]=max(R[i],r-i+1);
   } // R -> from index i to i+R[i]-1 is Pal 
   for(int i=0,l=0;i<n;i++){
      if(l>0 && s[i]==s[l-1]){
         l--;
      }else{
         while(!f(l+1,i+1))      l++;
      }
      L[i]=max(L[i],i-l+1);
   } // L-> from index i-L[i]+1 to i is Pal
}
\end{lstlisting}
\section{Data Structures}

\subsection{2D Prefix Sum}
\begin{lstlisting}
const int N =1005;
  int a[N][N], pref[N][N];
  for (int i =1; i <=n; i++) {
    for (int j =1; j <=m; j++) {
      pref[i][j] =pref[i-1][j] + pref[i][j-1] - pref[i-1][j-1] + a[i][j];
    }
  }
  auto query=[&](int x1, int y1, int x2, int y2){
    int ans =pref[x2][y2] - pref[x1-1][y2] - pref[x2][y1-1] + pref[x1-1][y1-1];
  };
\end{lstlisting}

\subsection{DSU}
\begin{lstlisting}
struct DSU {
   vector<int> par,sz;     DSU(){}
   DSU(int n){ init(n); }
   void init(int n){
      par.resize(n);
      iota(par.begin(),par.end(),0);
      sz.assign(n,1);
   }
   int find(int v){
      while(v!=par[v]){
         v=par[v]=par[par[v]]; 
      }
      return v;
   }
   bool merge(int a,int b){
      a=find(a);        b=find(b);
      if(a==b) return false;
      if(sz[a]<sz[b]) swap(a, b);
      par[b]=a;         sz[a]+=sz[b];
      return true;
   }
};
\end{lstlisting}

\subsection{SegTree}
\begin{lstlisting}
class segTree{ // 1-base Indexing
public:
   int sz;  vector<int> t;    segTree(){}
   segTree(int l){   sz=l;
      if(__builtin_popcount(sz)!=1){
         int x=31-__builtin_clz(sz);
         sz=(1LL<<(x+1));
      }
      t.assign(((sz<<1)|1),0);
   }
   int combine(int& left, int& right){
      int tm=left+right;      return tm;
   }
   void update(int root, int tl, int tr, int pos, int x){
      if(tl==tr){ t[root]=x;     return;  }
      int mid=(tl+tr)/2;
      if(pos<=mid)    update((root<<1),tl,mid,pos,x);
      else            update(((root<<1)|1),mid+1,tr,pos,x);
      t[root]=combine(t[(root<<1)],t[((root<<1)|1)]);
   }
   int query(int root,  int tl, int tr, int l, int r){
      if(l>tr || r<tl)    return 0;
      if(l<=tl && r>=tr)  return t[root];
      int mid=(tl+tr)/2;
      auto q1=query((root<<1),tl,mid,l,r);
      auto q2=query(((root<<1)|1),mid+1,tr,l,r);
      return combine(q1,q2);
   }
   void update(int pos, int x)   update(1,0,sz-1,pos,x);  
   int query(int l, int r)       return query(1,0,sz-1,l,r);
};
\end{lstlisting}

\subsection{2D SegTree}
\begin{lstlisting}

\end{lstlisting}

\subsection{LazySeg}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{Persistent Seg}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{BIT}
\begin{lstlisting}
struct BIT{ // 1-base query
   int sz;     vector<int> bit;
   BIT(int n){ sz=n;    bit.resize(sz+1,0);  }
   void update(int pos, int v){
      while(pos<=sz){
         bit[pos]+=v;
         pos=pos+(pos&(-pos));
      }
   }
   int sum(int pos){    int s=0;
      while(pos>0){
         s+=bit[pos];
         pos=pos-(pos&(-pos));
      }     
      return s;
   }
   int query(int l, int r)    return sum(r)-sum(l-1);
};

\end{lstlisting}

\subsection{BIT Range Update}
\begin{lstlisting}
const int N = 3e5 + 9; // 1-base query
struct RangeBIT {
  int64_t M[N], A[N];
  RangeBIT() {
    memset(M, 0, sizeof(M));
    memset(A, 0, sizeof(A));
  }
  void update(int i, int64_t mul, int64_t add) {
    for (; i < N; i +=i & (-i)) {
      M[i] +=mul;
      A[i] +=add;
    }
  }
  void upd(int l, int r, int64_t x) {
    update(l, x, -x * (l - 1));
    update(r + 1, -x, x * r);
  }
  int64_t query(int i) {
    int64_t mul =0, add =0;
    for (; i > 0; i -=i & (-i)) {
      mul +=M[i];
      add +=A[i];
    }
    return (mul * i + add);
  }
  int64_t query(int l, int r) {
    return query(r) - query(l - 1);
  }
};
\end{lstlisting}

\subsection{2D BIT with Range Update}
\begin{lstlisting}
template<typename T> // BIT2D<int32_t> bt(N,M);
struct BIT2D{ // 1-base
   int n,m;
   vector<vector<T>> t;
   BIT2D(int n,int m):n(n),m(m),t(n+2,vector<T>(m+2,0)){}
   void update(int x,int y,T val){
      for(int i=x;i<=n;i+=(i&-i))for(int j=y;j<=m;j+=(j&-j))t[i][j]+=val;
   }
   void range_update(int x1,int y1,int x2,int y2,T val){
      update(x1,y1,val);    update(x1,y2+1,-val);
      update(x2+1,y1,-val);     update(x2+1,y2+1,val);
   }
   T query(int x,int y)const{
      T sum=0;
      for(int i=x;i>0;i-=(i&-i))for(int j=y;j>0;j-=(j&-j))sum+=t[i][j];
      return sum;
   }
   T query(int x1,int y1,int x2,int y2)const{
      return query(x2,y2)-query(x1-1,y2)-query(x2,y1-1)+query(x1-1,y1-1);
   }
   void reset(){
      for(int i=0;i<=n;++i)fill(t[i].begin(),t[i].end(),0);
   }
};
\end{lstlisting}

\subsection{Sparse Table}
\begin{lstlisting}
const int N =1e5 + 9;
int t[N][18], a[N];
void build(int n) { //RMQ
  for(int i =1; i <=n; ++i) t[i][0] =a[i];
  for(int k =1; k < 18; ++k) {
    for(int i =1; i + (1 << k) - 1 <=n; ++i) {
      t[i][k] =min(t[i][k - 1], t[i + (1 << (k - 1))][k - 1]);
    }
  }
}
int query(int l, int r) {
  int k =31 - __builtin_clz(r - l + 1);
  return min(t[l][k], t[r - (1 << k) + 1][k]);
} 
\end{lstlisting}

\subsection{2D Sparse Table}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{Next Smaller Next Previous}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{Wavelet Tree}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{SegTree Hashing}
\begin{lstlisting}
// call pow_cal() inside Main Function
const int SZ=int(1e6)+9;
const int B1=151,mod1=127657753;
const int B2=239,mod2=987654319;
vector<int> P1(SZ,1),P2(SZ,1);
void pow_cal(){
   for(int i=1;i<SZ;i++){
      P1[i]=(P1[i-1]*B1)%mod1;
      P2[i]=(P2[i-1]*B2)%mod2;
   }
}
class segHash{
public:
   int n;   vector<int> T1,T2;
   segHash(const string& s){
      n=s.size();
      T1.assign(n*4+1,0);
      T2.assign(n*4+1,0);
      build(s,1,0,n-1);
   }
   void build(const string& s, int v, int tl, int tr){
      if(tl==tr){
         T1[v]=(s[tl]-'a'+1)%mod1;
         T2[v]=(s[tl]-'a'+1)%mod2;
         return;
      }
      int mid=(tl+tr)/2;
      build(s,v*2,tl,mid);
      build(s,v*2+1,mid+1,tr);
      T1[v]=(((T1[v*2]*P1[tr-mid])%mod1)+T1[v*2+1])%mod1;
      T2[v]=(((T2[v*2]*P2[tr-mid])%mod2)+T2[v*2+1])%mod2;
   }
   void update(int v, int tl, int tr, int pos, char c){
      if(tl==tr){
         T1[v]=(c-'a'+1)%mod1;
         T2[v]=(c-'a'+1)%mod2;
         return;
      }
      int mid=(tl+tr)/2;
      if(pos<=mid){
         update(v*2,tl,mid,pos,c);
      }else{
         update(v*2+1,mid+1,tr,pos,c);
      }
      T1[v]=(((T1[v*2]*P1[tr-mid])%mod1)+T1[v*2+1])%mod1;
      T2[v]=(((T2[v*2]*P2[tr-mid])%mod2)+T2[v*2+1])%mod2;
   }
   pair<int,int> query(int v, int tl, int tr, int l, int r){
      if(tl>r || tr<l)     return {0,0};
      if(l<=tl && tr<=r)   return {T1[v],T2[v]};
      int mid=(tl+tr)/2;
      auto left=query(v*2,tl,mid,l,min(mid,r));
      auto right=query(v*2+1,mid+1,tr,max(l,mid+1),r);
      int len=max(int(0),r-max(l,mid+1)+1);
      int H1=(((left.first*P1[len])%mod1)+right.first)%mod1;
      int H2=(((left.second*P2[len])%mod2)+right.second)%mod2;
      return {H1,H2};
   }
   void update(int pos, char c)  return update(1,0,n-1,pos-1,c);
   pair<int,int> geth(int l,int r)  return query(1,0,n-1,l-1,r-1);
};
\end{lstlisting}

\subsection{RMQ}
\begin{lstlisting}
struct RMQ {
    int n,t[2 * N];
    void build(int _n) {
        n =_n;
        for (int i =2 * n - 1; i >=n; i--) {
            t[i] =psum[i - n];
        }
        for (int i =n - 1; i > 0; --i) {
            t[i] =min(t[i << 1], t[i << 1 | 1]);
        }
    }
    int query(int l, int r) {
        r++;    int minV =1e18;
        for (l +=n, r +=n; l < r; l >>=1, r >>=1) {
            if (l & 1) minV =min(minV, t[l++]);
            if (r & 1) minV =min(minV, t[--r]);
        }
        return minV;
    }
} r;
\end{lstlisting}

\subsection{HLD}
\begin{lstlisting}
template<typename T>
struct segTree{
   int n;   vector<T> t, lazy;
   T neutral =0; // 0 for sum, -inf for max, +inf for min
   SegTree(int n =0): n(n), t(4*n, neutral), lazy(4*n, 0){}
   T combine(T a, T b){}
   void push(int v, int tl, int tr){}
   void build(const vector<T>& a, int v, int tl, int tr){}
   void build(const vector<T>& a) { build(a, 1, 1, n); }
   void update(int v, int tl, int tr, int l, int r, T add){}
   void update(int l, int r, T add){update(1, 1, n, l, r, add);}
   T query(int v, int tl, int tr, int l, int r){}
   T query(int l, int r) { return query(1, 1, n, l, r); }
   void set_value(int pos, T val) { // overwrite
      T cur =query(pos, pos);
      update(pos, pos, val - cur);
   }
};
template<typename T>
struct HLD {
   int n,timer;   vector<vector<int>> g;
   vector<int> parent, depth, heavy, head, pos, sz;
   vector<T> flat;   SegTree<T> seg;
   HLD(int n): n(n), g(n+1), parent(n+1), depth(n+1),heavy(n+1,-1), head(n+1), pos(n+1), sz(n+1), timer(0) {}
   void add_edge(int u, int v) {
      g[u].push_back(v);
      g[v].push_back(u);
   }
   int dfs(int u, int p) {
      parent[u] =p; sz[u] =1;
      int max_sz =0;
      for (int v : g[u]) if (v !=p) {
         depth[v] =depth[u] + 1;
         int sub =dfs(v, u);    sz[u] +=sub;
         if (sub > max_sz) max_sz =sub, heavy[u] =v;
      }
      return sz[u];
   }
   void decompose(int u, int h, const vector<T>& val) {
      head[u] =h;   pos[u] =++timer; flat[timer] =val[u];
      if (heavy[u] !=-1) decompose(heavy[u], h, val);
      for (int v : g[u])if (v !=parent[u] && v !=heavy[u])   decompose(v, v, val);
   }
   void init(const vector<T>& val, int root =1) {
      flat.assign(n+1, 0);
      dfs(root, 0);
      timer =0;
      decompose(root, root, val);
      seg =SegTree<T>(n);
      seg.build(flat);
   }
   void update_path(int u, int v, T add) {    // Path range add
      while (head[u] !=head[v]) {
         if (depth[head[u]] < depth[head[v]]) swap(u, v);
         seg.update(pos[head[u]], pos[u], add);
         u =parent[head[u]];
      }
      if (depth[u] > depth[v]) swap(u, v);
      seg.update(pos[u], pos[v], add);
   }
   T query_path(int u, int v) {    // Path query (need to update)
      T res =0; // check
      while (head[u] !=head[v]) {
         if (depth[head[u]] < depth[head[v]]) swap(u, v);
         res +=seg.query(pos[head[u]], pos[u]);
         u =parent[head[u]];
      }
      if (depth[u] > depth[v]) swap(u, v);
      res +=seg.query(pos[u], pos[v]);
      return res;
   }
   void update_subtree(int u, T add) {    // Subtree range add
      seg.update(pos[u], pos[u] + sz[u] - 1, add);
   }
   T query_subtree(int u) {   // Subtree query
      return seg.query(pos[u], pos[u] + sz[u] - 1);
   }
   void set_value(int u, T val) {   // Point set
      seg.set_value(pos[u], val);
   }
   int lca(int u, int v) {
      while (head[u] !=head[v]) {
         if (depth[head[u]] < depth[head[v]]) swap(u, v);
         u =parent[head[u]];
      }
      return depth[u] < depth[v] ? u : v;
   }
};
\end{lstlisting}

\section{Graph and Trees}

\subsection{LCA}
\begin{lstlisting}
const int N =3e5 + 9, LG =18;
vector<int> g[N];
int par[N][LG + 1], dep[N], sz[N];
void dfs(int u, int p =0) {
    par[u][0] =p;
    dep[u] =dep[p] + 1;
    sz[u] =1;
    for (int i =1; i <=LG; i++) par[u][i] =par[par[u][i - 1]][i - 1];
    for (auto v: g[u]) if (v !=p) {
        dfs(v, u);
        sz[u] +=sz[v];
    }
}
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int k =LG; k >=0; k--) if (dep[par[u][k]] >=dep[v]) u =par[u][k];
    if (u ==v) return u;
    for (int k =LG; k >=0; k--) if (par[u][k] !=par[v][k]) u =par[u][k], v =par[v][k];
    return par[u][0];
}
int kth(int u, int k) {
    assert(k >=0);
    for (int i =0; i <=LG; i++) if (k & (1 << i)) u =par[u][i];
    return u;
}
int dist(int u, int v) {
    int l =lca(u, v);
    return dep[u] + dep[v] - (dep[l] << 1);
}
//kth node from u to v, 0th node is u
int go(int u, int v, int k) {
    int l =lca(u, v);
    int d =dep[u] + dep[v] - (dep[l] << 1);
    assert(k <=d);
    if (dep[l] + k <=dep[u]) return kth(u, k);
    k -=dep[u] - dep[l];
    return kth(v, dep[v] - dep[l] - k);
}
\end{lstlisting}

\subsection{Tree Diameter}
\begin{lstlisting}
const int N =2e5 + 9;
vector<int> g[N];
int farthest(int s, int n, vector<int> &d) {
  static const int inf =N;
  d.assign(n + 1, inf); d[s] =0;
  vector<bool> vis(n + 1);
  queue<int> q; q.push(s);
  vis[s] =1; int last =s;
  while (!q.empty()) {
    int u =q.front(); q.pop();
    for (int v: g[u]) {
      if (vis[v]) continue;
      d[v] =d[u] + 1;
      q.push(v); vis[v] =1;
    }
    last =u;
  }
  return last;
}
vector<int> dx, dy;
int x =farthest(1, n, dx);
int y =farthest(x, n, dx);
\end{lstlisting}

\subsection{Cycle Detection}
\begin{lstlisting}
const int N =5e5 + 9;
vector<pair<int, int>> g[N];
int vis[N], par[N], e_id[N];
vector<int> cycle; // simple cycle, contains edge ids
bool dfs(int u) {
  if (!cycle.empty()) return 1;
  vis[u] =1;
  for (auto [v, id] : g[u]) {
    if (v !=par[u]) {
      if (vis[v] ==0) {
        par[v] =u;
        e_id[v] =id;
        if (dfs(v)) return 1;
      }else if (vis[v] ==1) {
        cycle.push_back(id);    // cycle here
        for (int x =u; x !=v; x =par[x]) {
          cycle.push_back(e_id[x]);
        }
        return 1;
      }
    }
  }
  vis[u] =2;
  return 0;
}
\end{lstlisting}

\subsection{SCC (Kosaraju)}
\begin{lstlisting}
// DFS Function to reach destination
bool dfs(int curr, int des, vector<vector<int>> &adj, vector<int> &vis) {
    if (curr ==des) return true;
    vis[curr] =1;
    for (auto x : adj[curr]) {
        if (!vis[x] && dfs(x, des, adj, vis)) return true;
    }
    return false;
}

// To tell whether there is path from source to destination
bool isPath(int src, int des, vector<vector<int>> &adj) {
    vector<int> vis(adj.size() + 1, 0);
    return dfs(src, des, adj, vis);
}

// Function to return all the strongly connected components of a graph
vector<vector<int>> findSCC(int n, vector<vector<int>> &a) {
    vector<vector<int>> ans;
    vector<int> is_scc(n + 1, 0);
    vector<vector<int>> adj(n + 1);
    for (int i =0; i < a.size(); i++) {
        adj[a[i][0]].push_back(a[i][1]);
    }
    for (int i =1; i <=n; i++) {
        if (!is_scc[i]) {
            vector<int> scc;
            scc.push_back(i);
            for (int j =i + 1; j <=n; j++) {
                if (!is_scc[j] && isPath(i, j, adj) && isPath(j, i, adj)) {
                    is_scc[j] =1;
                    scc.push_back(j);
                }
            }
            ans.push_back(scc);
        }
    }
    return ans;
}
\end{lstlisting}

\subsection{Articulation Point}
\begin{lstlisting}
const int N =3e5 + 9;
int T, low[N], dis[N], art[N];
vector<int> g[N];
void dfs(int u, int pre =0) {
  low[u] =dis[u] =++T;
  int child =0;
  for(auto v: g[u]) {
    if(!dis[v]) {
      dfs(v, u);
      low[u] =min(low[u], low[v]);
      if(low[v] >=dis[u] && pre !=0) art[u] =1;
      ++child;
    }
    else if(v !=pre) low[u] =min(low[u], dis[v]);
  }
  if(pre ==0 && child > 1) art[u] =1;
}
\end{lstlisting}

\subsection{Articulation Bridge}
\begin{lstlisting}

\end{lstlisting}

\subsection{Dijsktra}
\begin{lstlisting}
const int N =int(2e5)+3,inf=int(1e16);
vector<pair<int,int>> g[N]; // in graph weight first & neighbour second
vector<int> dis(N,inf);
void SP(int source){
   priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
   dis[source]=0;          pq.push({0,source});
   par[source]=-1;        // if parent is necessary 
   while(!pq.empty()){
      int v=pq.top().second,wt=pq.top().first;  pq.pop();
      if(dis[v]<wt)    continue; 
      for(auto &it:g[v]){ 
         int child_v=it.second,child_wt=it.first;
         if(dis[v]+child_wt<dis[child_v]){
            par[child_v]=v;    // if parent is necessary 
            dis[child_v]=dis[v]+child_wt;
            pq.push({dis[child_v],child_v});
         }
      }
   }
}
\end{lstlisting}

\subsection{Dinic's Algo}
\begin{lstlisting}
struct Edge {
    int u, v;
    int64_t cap, flow;
    Edge(int u, int v, int64_t cap) : u(u), v(v), cap(cap), flow(0) {}
};
class Dinic {
public:
    int N;
    vector<Edge> E;
    vector<vector<int>> g;
    vector<int> d, pt;
    Dinic(int N) : N(N), E(0), g(N), d(N), pt(N) {}
    void AddEdge(int u, int v, int64_t cap) {
        if (u ^ v) {
            E.emplace_back(u, v, cap);
            g[u].emplace_back(E.size() - 1);
            E.emplace_back(v, u, 0);
            g[v].emplace_back(E.size() - 1);
        }
    }
    bool BFS(int S, int T) {
        queue<int> q({S});
        fill(d.begin(), d.end(), N + 1);
        d[S] =0;
        while (!q.empty()) {
            int u =q.front();
            q.pop();
            if (u ==T) break;
            for (int k : g[u]) {
                Edge &e =E[k];
                if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {
                    d[e.v] =d[e.u] + 1;
                    q.emplace(e.v);
                }
            }
        }
        return d[T] !=N + 1;
    }
    int64_t DFS(int u, int T, int64_t flow =-1) {
        if (u ==T || flow ==0) return flow;
        for (int &i =pt[u]; i < g[u].size(); ++i) {
            Edge &e =E[g[u][i]];
            Edge &oe =E[g[u][i] ^ 1];
            if (d[e.v] ==d[e.u] + 1) {
                int64_t amt =e.cap - e.flow;
                if (flow !=-1 && amt > flow) amt =flow;
                if (int64_t pushed =DFS(e.v, T, amt)) {
                    e.flow +=pushed;
                    oe.flow -=pushed;
                    return pushed;
                }
            }
        }
        return 0;
    }
    int64_t MaxFlow(int S, int T) {
        int64_t total =0;
        while (BFS(S, T)) {
            fill(pt.begin(), pt.end(), 0);
            while (int64_t pushed =DFS(S, T)) {
                total +=pushed;
            }
        }
        return total;
    }
};
\end{lstlisting}

\section{DP}

\subsection{Submask Enumeration}
\begin{lstlisting}
for(int k=1;k<(1<<n);k++){
   for(int sub=(k&(k-1));;sub=(k&(sub-1))){
      if(sub==0)  break;
   }
}
\end{lstlisting}

\subsection{BitMask DP}
\begin{lstlisting}

\end{lstlisting}

\subsection{SOS DP}
\begin{lstlisting}
const int B =20;
int a[1 << B], f[1 << B], g[1 << B];
// sum over subsets
for (int i =0; i < B; i++) {
    for (int mask =0; mask < (1 << B); mask++) {
        if ((mask & (1 << i)) !=0) {
            f[mask] +=f[mask ^ (1 << i)];
        }
    }
}
// sum over supersets
for (int i =0; i < B; i++) {
    for (int mask =(1 << B) - 1 ; mask >=0 ; mask--) {
        if ((mask & (1 << i)) ==0) g[mask] +=g[mask ^ (1 << i)] ;
    }
}
\end{lstlisting}

\section{Number Theory}

\subsection{Range BitS OP}
\begin{lstlisting}
struct RangeBit{
   static int64_t OR(int64_t A, int64_t B) {
      if (A ==B) return A;
      uint64_t ua =static_cast<uint64_t>(A);
      uint64_t ub =static_cast<uint64_t>(B);
      uint64_t diff =ua ^ ub;
      int msb =63 - __builtin_clzll(diff);
      uint64_t mask =(msb ==63) ? UINT64_MAX : ((1ULL << (msb + 1)) - 1ULL);
      uint64_t res_u =ub | mask;
      return static_cast<int64_t>(res_u);
   }
   static int64_t AND(int64_t A, int64_t B) {
      if (A ==B) return A;
      uint64_t ua =static_cast<uint64_t>(A);
      uint64_t ub =static_cast<uint64_t>(B);
      uint64_t diff =ua ^ ub;
      int msb =63 - __builtin_clzll(diff);
      uint64_t mask =~((1ULL << (msb + 1)) - 1ULL);
      uint64_t res_u =ub & mask;
      return static_cast<int64_t>(res_u);
   }
   static int64_t XOR(int64_t A, int64_t B) {
      auto xor_to =[](int64_t x) -> int64_t {
         uint64_t ux =static_cast<uint64_t>(x);
         uint64_t res;
         switch (ux & 3ULL) {
            case 0: res =ux; break;
            case 1: res =1ULL; break;
            case 2: res =ux + 1ULL; break;
            default: res =0ULL; break;
         }
         return static_cast<int64_t>(res);
      };
      if (A ==0) return xor_to(B);
      return xor_to(B) ^ xor_to(A - 1);
   }
};
auto OR =RangeBit::OR;
auto AND =RangeBit::AND;
auto XOR =RangeBit::XOR;
\end{lstlisting}
\subsection{Big MOD}
\begin{lstlisting}
const int MOD=int(1e9)+7;
int64_t fow(int64_t a,int64_t b){
   int64_t ans=1;
   while(b){
      if(b&1){ ans=(ans*a)%MOD;  }
      a=(a*a)%MOD;
      (b>>=1);
   }
   return ans;
}
\end{lstlisting}

\subsection{Sieve}
\begin{lstlisting}
vector<int> pr={2};
void sieve(){
   const int SZ=int(1e5)+7;
   vector<bool> isp(SZ+1,true);
   for(int i=3;i*i<=SZ;i+=2)if(isp[i])for(int j=i*i;j<=SZ;isp[j]=false,j+=(i<<1));
   for(int i=3;i<SZ;i+=2)if(isp[i]) pr.push_back(i);
}
\end{lstlisting}

\subsection{Segmented Sieve}
\begin{lstlisting}
// Generate all primes from l to r using segmented sieve in O((r - l) log (r) + sqrt(r))  // needs sieve(limit)
vector<int64_t> segmented_sieve(int64_t l, int64_t r) {
   if (l == 1)    l++;
   int limit = sqrtl(r);
   while (limit * limit <= r) limit++;
   while (limit * limit > r) limit--;
   auto primes = sieve(limit);
   vector<bool> is_prime(r - l + 1, true);
   for (int64_t p : primes) {
      int64_t start = max(p * p, (l + p - 1) / p * p);
      for (int64_t j = start; j <= r; j += p) {
         is_prime[j - l] = false;
      }
   }
   vector<int64_t> vec;
   for (int64_t i = l; i <= r; ++i) {
      if (is_prime[i - l])    vec.push_back(i);
   }
   return vec;
}
\end{lstlisting}

\subsection{Linear Sieve}
\begin{lstlisting}
const int N =1e5 + 9;
int spf[N];
vector<int> primes;
void sieve() {
  for(int i =2; i < N; i++) {
    if (spf[i] ==0) spf[i] =i, primes.push_back(i);
    int sz =primes.size();
    for (int j =0; j < sz && i * primes[j] < N && primes[j] <=spf[i]; j++) {
      spf[i * primes[j]] =primes[j];
    }
  }
}
\end{lstlisting}

\subsection{Phi Function}
\begin{lstlisting}
const int N = e5 + 9;
int phi[N];
void totient() {
  for (int i =1; i < N; i++) phi[i] =i;
  for (int i =2; i < N; i++) {
    if (phi[i] ==i) {
      for (int j =i; j < N; j +=i) phi[j] -=phi[j] / i;
    }
  }
}
\end{lstlisting}

\section{Math}
\subsection{Mathematical Formulas}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{FFT}
\begin{lstlisting}
const int N =3e5 + 9;
const double PI =acos(-1);
struct base {
  double a, b;
  base(double a =0, double b =0) : a(a), b(b) {}
  const base operator + (const base &c) const
    { return base(a + c.a, b + c.b); }
  const base operator - (const base &c) const
    { return base(a - c.a, b - c.b); }
  const base operator * (const base &c) const
    { return base(a * c.a - b * c.b, a * c.b + b * c.a); }
};
void fft(vector<base> &p, bool inv =0) {
  int n =p.size(), i =0;
  for(int j =1; j < n - 1; ++j) {
    for(int k =n >> 1; k > (i ^=k); k >>=1);
    if(j < i) swap(p[i], p[j]);
  }
  for(int l =1, m; (m =l << 1) <=n; l <<=1) {
    double ang =2 * PI / m;
    base wn =base(cos(ang), (inv ? 1. : -1.) * sin(ang)), w;
    for(int i =0, j, k; i < n; i +=m) {
      for(w =base(1, 0), j =i, k =i + l; j < k; ++j, w =w * wn) {
        base t =w * p[j + l];
        p[j + l] =p[j] - t;
        p[j] =p[j] + t;
      }
    }
  }
  if(inv) for(int i =0; i < n; ++i) p[i].a /=n, p[i].b /=n;
}
vector<long long> multiply(vector<int> &a, vector<int> &b) {
  int n =a.size(), m =b.size(), t =n + m - 1, sz =1;
  while(sz < t) sz <<=1;
  vector<base> x(sz), y(sz), z(sz);
  for(int i =0 ; i < sz; ++i) {
    x[i] =i < (int)a.size() ? base(a[i], 0) : base(0, 0);
    y[i] =i < (int)b.size() ? base(b[i], 0) : base(0, 0);
  }
  fft(x), fft(y);
  for(int i =0; i < sz; ++i) z[i] =x[i] * y[i];
  fft(z, 1);
  vector<long long> ret(sz);
  for(int i =0; i < sz; ++i) ret[i] =(long long) round(z[i].a);
  while((int)ret.size() > 1 && ret.back() ==0) ret.pop_back();
  return ret;
}
\end{lstlisting}

\subsection{Derangement}
\begin{lstlisting}
int d[N];   d[0] = 1; d[1] = 0;
for (int i = 1; i < N; i++) {
    d[i] = 1LL * (i - 1) * (d[i - 1] + d[i - 2]) % mod;
}
\end{lstlisting}

\subsection{Pythagorean Triplets}
\begin{lstlisting}
const int N=int(1e6);
vector<pair<int,int>> ans(N+1); //ans[c] = {{a, b}},        s.t. a^2 + b^2 = c^2
void Pythagorean_Triplets(){
   int cnt =0;
  for (int m =1; m * m <=N; m++) {
    for (int n =1; n <m; n++) {
      if ((n & 1) ==(m & 1)) continue;
      int a =m * m - n * n, b =2 * m * n, c =m * m + n * n;
      if (__gcd(a, b) > 1) continue;
      for (int k =1; k * c < N; k++) { // use only k =1 to generate only primitive triples 
        ans[c * k].emplace_back(a * k, b * k);
        cnt++;
      }
      // cnt+=N/c;
    }
  }
}
\end{lstlisting}

\subsection{Mat Expo}
\begin{lstlisting}
struct Mat{
   int n,m;    vector<vector<int>> a;  Mat(){}
   Mat(int _n, int _m){
      n=_n;          m=_m; a.assign(n,vector<int> (m,0));
   }
   Mat(vector<vector<int>> v){
      n=v.size();    m=n?v[0].size():0;   a=v;
   }
   inline void make_unit(){
      assert(n==m);
      for(int i=0;i<n;i++){
         for(int j=0;j<n;j++){
            a[i][j]=(i==j);
         }
      }
   }
   inline Mat operator + (const Mat &b){
      assert(n==b.n && m==b.m);
      Mat ans=Mat(n,m);
      for(int i=0;i<n;i++){
         for(int j=0;j<m;j++){
            ans.a[i][j]=(a[i][j]+b.a[i][j])%mod;
         }
      }
      return ans;
   }
   inline Mat operator - (const Mat& b){
      assert(n==b.n && m==b.m);
      Mat ans=Mat(n,m);
      for(int i=0;i<n;i++){
         for(int j=0;j<m;j++){
            ans.a[i][j]=(a[i][j]-b.a[i][j]+mod)%mod;
         }
      }
      return ans;
   }
   inline Mat operator * (const Mat& b){
      assert(m==b.n);
      Mat ans=Mat(n,b.m);
      for(int i=0;i<n;i++){
         for(int j=0;j<b.m;j++){
            for(int k=0;k<m;k++){
               ans.a[i][j]=(ans.a[i][j]+a[i][k]*b.a[k][j]%mod)%mod;
            }
         }
      }
      return ans;
   }
   inline Mat fow(int64_t k){
      assert(n==m);
      Mat ans(n,m),base=*this;
      ans.make_unit();
      while(k){
         if(k&1){
            ans=ans*base;
         }
         base=base*base;
         k>>=1LL;
      }
      return ans;
   }
   inline Mat& operator +=(const Mat& b){ return (*this)=(*this)+b; }
   inline Mat& operator -=(const Mat& b){ return (*this)=(*this)-b; }
   inline Mat& operator *=(const Mat& b){ return (*this)=(*this)*b; }
   inline bool operator ==(const Mat& b){ return a==b.a; }
   inline bool operator !=(const Mat& b){ return a!=b.a; }
};
\end{lstlisting}

\subsection{XOR Basis}
\begin{lstlisting}
const int LOG_K =60; // Adjust as needed
struct XorBasis {
    vector<int64_t> basis;
    int64_t N =0, tmp =0;
    void add(int64_t x) {
        N++;
        tmp |=x;
        for (auto &i : basis) {
            x =min(x, x ^ i);
        }
        if (!x) return;
        for (auto &i : basis) {
            if ((i ^ x) < i) {
                i ^=x;
            }
        }
        basis.push_back(x);
        sort(basis.begin(), basis.end());
    }
    int64_t size() {
        return (int64_t)basis.size();
    }
    void clear() {
        N =0;
        tmp =0;
        basis.clear();
    }
    bool possible(int64_t x) {
        for (auto &i : basis) {
            x =min(x, x ^ i);
        }
        return !x;
    }
    int64_t maxxor(int64_t x =0) {
        for (auto &i : basis) {
            x =max(x, x ^ i);
        }
        return x;
    }
    int64_t minxor(int64_t x =0) {
        for (auto &i : basis) {
            x =min(x, x ^ i);
        }
        return x;
    }
    int64_t cntxor(int64_t x) {
        if (!possible(x)) return 0;
        return (1LL << (N - size()));
    }
    int64_t sumOfAll() {
        int64_t ans =tmp * (1LL << (N - 1));
        return ans;
    }
    int64_t kth(int64_t k) {
        int64_t sz =size();
        if (k > (1LL << sz)) return -1;
        k--;
        int64_t ans =0;
        for (int64_t i =0; i < sz; i++) {
            if (k >> i & 1) {
                ans ^=basis[i];
            }
        }
        return ans;
    }
};
\end{lstlisting}

\subsection{Nth Fibonacci}
\begin{lstlisting}
map<int64_t, int64_t> dp;     // works for n<=1e18
int64_t f(int64_t n) {
    if (n <=2) return n >=1; // depends on problem
    if (dp.count(n)) return dp[n];
    auto a =f(n / 2);
    auto b =f(n / 2 + 1);
    if (n % 2 ==0) {
        dp[n] =((((b*2LL)%mod - (a%mod)+mod))%mod * a)%mod;
    } else {
        dp[n] =((a * a)%mod + (b * b)%mod)%mod;
    }
    return dp[n];
}
\end{lstlisting}

\section{Geometry}
\subsection{Geometrical Formulas}
\begin{lstlisting}

\end{lstlisting}


\subsection{Point}
\subsection{Struct}
\begin{lstlisting}

\end{lstlisting}

\section{Miscellaneous}
\subsection{Inversions}
\begin{lstlisting}
    
\end{lstlisting}

\subsection{BIG INT}
\begin{lstlisting}
    
\end{lstlisting}




\end{document}
